use crate::package_path::get_package_path;
use glang_logging::{log_header, log_message, log_package_status};
use reqwest::blocking::get;
use serde::Deserialize;
use std::{fs, fs::File, io::Cursor, io::Read};
use stringcase::snake_case;
use toml::Table;
use zip::ZipArchive;

#[derive(Deserialize)]
struct PackageRegistry {
    name: String,
    url: String,
}

pub fn is_package_installed(package: &str) -> bool {
    let package_path = get_package_path().join(package);

    package_path.exists()
}

pub fn create_package_dir() {
    let config_path = dirs::home_dir()
        .expect("Unable to retrieve user home directory")
        .join(".glang");

    if !config_path.exists() {
        fs::create_dir_all(&config_path).expect("Unable to build '.glang' configuration directory");
    }

    let package_dir = get_package_path();

    if !package_dir.exists() {
        fs::create_dir_all(&package_dir).expect("Unable to create 'kennels' directory");

        let _ = fs::write(
            package_dir.join("kennels.glang"),
            "# this file is automatically @generated by glang\n# not intended for manual editing\n",
        );
    }
}

pub fn add_package(name: &str) {
    create_package_dir();

    log_header("Checking kennels registry");

    let mut resp =
        get("https://raw.githubusercontent.com/george-language/glang/main/registry.json")
            .expect("Unable to retrieve kennels registry");

    let mut registry_json = String::new();

    resp.read_to_string(&mut registry_json)
        .expect("Unable to read registry data");

    let packages: Vec<PackageRegistry> =
        serde_json::from_str(&registry_json).expect("Unable to parse registry json");

    let package = packages
        .iter()
        .find(|p| p.name == name)
        .expect("Kennel not found in registry");

    let package_path = get_package_path().join(&package.name);

    if package_path.exists() {
        log_package_status(&package.name, true);

        return;
    }

    log_message(&format!("Downloading kennel from '{}'", package.url));

    let zip_bytes = get(&package.url)
        .expect("Unable to get zip content")
        .bytes()
        .expect("Unable to get zip bytes");

    log_message(&format!(
        "Moving kennel to '{}'",
        package_path.to_string_lossy()
    ));

    let reader = Cursor::new(zip_bytes);
    let mut archive = ZipArchive::new(reader).expect("Unable to create zip archive for kennel");

    for i in 0..archive.len() {
        let mut file = archive.by_index(i).unwrap();
        let path = match file.enclosed_name() {
            Some(p) => {
                let mut components = p.components();
                components.next();

                let stripped = components.as_path();
                package_path.join(stripped)
            }
            None => continue,
        };

        if file.name().ends_with('/') {
            fs::create_dir_all(&path).expect("Unable to create kennel directory");
        } else {
            if let Some(parent) = path.parent() {
                fs::create_dir_all(parent).expect("Unable to create kennel directory");
            }

            let mut outfile = File::create(&path).unwrap();
            std::io::copy(&mut file, &mut outfile).unwrap();
        }
    }

    log_message("Updating 'kennels.glang'");

    let package_toml =
        fs::read_to_string(get_package_path().join(&package.name).join("kennel.toml"))
            .expect("Error reading 'kennel.toml'")
            .as_str()
            .parse::<Table>()
            .expect("Error parsing 'kennel.toml'");
    let name = snake_case(
        package_toml["name"]
            .as_str()
            .expect("'name' field of 'kennel.toml' must be a string"),
    );
    let description = package_toml["description"]
        .as_str()
        .unwrap_or("No description");
    let version = package_toml["version"]
        .as_str()
        .expect("'version' field of 'kennel.toml' must be a valid version number");
    let entry = package_toml["entry"]
        .as_str()
        .expect("'entry' field of 'kennel.toml' must be a path to the glang entry point file");
    let requirements = package_toml["requires"]
        .as_array()
        .expect("'requires' field of 'kennel.toml' must be an array of external kennel names");

    for requirement in requirements {
        let pkg_name = requirement
            .as_str()
            .expect("Invalid requirement of kennel.toml");

        if pkg_name == name {
            println!(
                "Cannot require the kennel dependency of another kennel (circular requirements)",
            );

            return;
        }

        if is_package_installed(pkg_name) {
            log_message(&format!("Requirement '{}' is already installed", &pkg_name));

            continue;
        }

        add_package(pkg_name);
    }

    let imports_file = get_package_path().join("kennels.glang");

    let mut imports = fs::read_to_string(&imports_file).expect("Error reading 'kennels.glang'");
    imports.push_str(
        format!(
            "\n# {} {}: {}\nobj {} = _env(\"GLANG_PKG\") + \"/{}/{}\";",
            &package.name, &version, &description, &name, &package.name, &entry
        )
        .as_str(),
    );
    let _ = fs::write(&imports_file, imports);

    log_message(&format!(
        "Kennel '{} {}' installed successfully!",
        &package.name, &version
    ));
}

pub fn remove_package(package: &str) {
    create_package_dir();

    let package_path = get_package_path().join(package);

    if package_path.exists() {
        let _ = fs::remove_dir_all(&package_path);
    } else {
        log_header(&format!("Removing '{}'", &package));
        log_package_status(package, false);

        return;
    }

    let kennels_file = get_package_path().join("kennels.glang");
    let contents = fs::read_to_string(&kennels_file)
        .expect("Error reading 'kennels.glang'")
        .lines()
        .filter(|line| !line.contains(package))
        .collect::<Vec<_>>()
        .join("\n");

    let _ = fs::write(&kennels_file, contents);

    println!("Kennel '{}' removed", &package);
}

pub fn update_package(package: &str) {
    if is_package_installed(package) {
        remove_package(package);
        add_package(package);
    } else {
        log_header(&format!("Updating '{}'", &package));
        log_package_status(package, false);
    }
}
