use reqwest::blocking::get;
use serde::Deserialize;
use simply_colored::*;
use std::{fs, io::Read, path::PathBuf};
use std::{fs::File, io::Cursor};
use toml::Table;
use zip::ZipArchive;

#[derive(Deserialize)]
struct PackageRegistry {
    name: String,
    url: String,
}

fn get_package_path() -> PathBuf {
    std::env::var("GLANG_PKG")
        .map(PathBuf::from)
        .unwrap_or_else(|_| PathBuf::from("kennels"))
}

fn is_snake_case(s: &str) -> bool {
    !s.is_empty()
        && s.chars()
            .all(|c| c.is_ascii_lowercase() || c.is_ascii_digit() || c == '_')
}

pub fn package_installed(package: &str) -> bool {
    let package_path = get_package_path().join(&package);

    package_path.exists()
}

pub fn create_package_dir() {
    let kennels_dir = get_package_path();

    if !kennels_dir.exists() {
        match fs::create_dir_all(&kennels_dir) {
            Ok(_) => {}
            Err(e) => {
                println!("Error creating 'kennels' dir: {}", e);
                return;
            }
        }

        let _ = fs::write(
            kennels_dir.join("kennels.glang"),
            "# this file is automatically generated and edited by glang
# not intended for manual editing

obj std_os = _env(\"GLANG_STD\") + \"/std/os.glang\";
obj std_hashmap = _env(\"GLANG_STD\") + \"/std/hashmap.glang\";
obj std_format = _env(\"GLANG_STD\") + \"/std/format.glang\";
obj std_math = _env(\"GLANG_STD\") + \"/std/math.glang\";",
        );
    }
}

pub fn add_package(name: &str) {
    create_package_dir();

    let mut resp = match get(
        "https://raw.githubusercontent.com/mpsoftwarefoundation/GeorgeLanguage/main/registry.json",
    ) {
        Ok(r) => r,
        Err(e) => {
            println!("{DIM_RED}Failed to retrieve registry: {}{RESET}", e);

            return;
        }
    };

    let mut registry_json = String::new();

    if let Err(e) = resp.read_to_string(&mut registry_json) {
        println!("{DIM_RED}Failed to read registry data: {}{RESET}", e);

        return;
    }

    let packages: Vec<PackageRegistry> = match serde_json::from_str(&registry_json) {
        Ok(p) => p,
        Err(e) => {
            println!("{DIM_RED}Failed to parse registry JSON: {}{RESET}", e);

            return;
        }
    };

    let package = match packages.iter().find(|p| p.name == name) {
        Some(p) => p,
        None => {
            println!("{DIM_RED}Kennel '{}' not found in registry{RESET}", name);

            return;
        }
    };

    let package_path = get_package_path().join(&package.name);

    if package_path.exists() {
        println!("‚úÖ Kennel '{}' is already installed", package.name);
        println!(
            "üí° To update, use {BOLD}`glang update {}`{RESET}",
            package.name
        );

        return;
    }

    println!("üìÅ Downloading kennel from '{}'", package.url);

    let zip_bytes = match get(&package.url) {
        Ok(r) => match r.bytes() {
            Ok(b) => b,
            Err(e) => {
                println!("{DIM_RED}Failed to get zip content: {}", e);

                return;
            }
        },
        Err(e) => {
            println!("{DIM_RED}Failed to download zip: {}", e);

            return;
        }
    };

    println!(
        "üéØ Extracting kennel to '{}'",
        package_path.to_string_lossy().to_string()
    );

    let reader = Cursor::new(zip_bytes);
    let mut archive = match ZipArchive::new(reader) {
        Ok(archive) => archive,
        Err(e) => {
            println!("{DIM_RED}Failed to open zip archive: {}{RESET}", e);

            return;
        }
    };

    for i in 0..archive.len() {
        let mut file = archive.by_index(i).unwrap();
        let path = match file.enclosed_name() {
            Some(p) => {
                let mut components = p.components();
                components.next();

                let stripped = components.as_path();
                package_path.join(stripped)
            }
            None => continue,
        };

        if file.name().ends_with('/') {
            fs::create_dir_all(&path).unwrap_or_else(|e| {
                println!("{DIM_RED}Failed to create dir {:?}: {}{RESET}", path, e);
            });
        } else {
            if let Some(parent) = path.parent() {
                fs::create_dir_all(parent).unwrap_or_else(|e| {
                    println!("{DIM_RED}Failed to create dir {:?}: {}{RESET}", parent, e);
                });
            }

            let mut outfile = File::create(&path).unwrap();
            std::io::copy(&mut file, &mut outfile).unwrap();
        }
    }

    println!("üëç Updating 'kennels.glang'");

    let package_toml =
        fs::read_to_string(get_package_path().join(&package.name).join("kennel.toml"))
            .expect("Error reading 'kennel.toml'")
            .as_str()
            .parse::<Table>()
            .expect("Error parsing 'kennel.toml'");
    let name = package_toml["name"]
        .as_str()
        .expect("'name' field of 'kennel.toml' must be a string");
    let description = package_toml["description"]
        .as_str()
        .unwrap_or("No description");
    let version = package_toml["version"]
        .as_str()
        .expect("'version' field of 'kennel.toml' must be a valid version number");
    let entry = package_toml["entry"]
        .as_str()
        .expect("'entry' field of 'kennel.toml' must be a path to the glang entry point file");
    let requirements = package_toml["requires"]
        .as_array()
        .expect("'requires' field of 'kennel.toml' must be an array of external kennel names");

    if !is_snake_case(&name) {
        println!(
            "{DIM_RED}'name' field of {}'s 'kennel.toml' must be a proper snake case name{RESET}",
            package.name
        );

        return;
    }

    for requirement in requirements {
        let pkg_name = requirement.as_str().unwrap_or("");

        if !is_snake_case(&pkg_name) {
            println!(
                "{DIM_RED}'name' field of {pkg_name}'s 'kennel.toml' must be a proper snake case name{RESET}"
            );

            return;
        }

        if pkg_name == name {
            println!(
                "{DIM_RED}Cannot require the Kennel dependency of another Kennel (circular requirements){RESET}"
            );

            return;
        }

        add_package(pkg_name);
    }

    let imports_file = get_package_path().join("kennels.glang");

    let mut imports = fs::read_to_string(&imports_file).expect("Error reading 'kennels.glang'");
    imports.push_str(
        format!(
            "\n# {} {}: {}\nobj {} = _env(\"GLANG_PKG\") + \"/{}/{}\";",
            &package.name, &version, &description, &name, &package.name, &entry
        )
        .as_str(),
    );
    let _ = fs::write(&imports_file, imports);

    println!(
        "‚úÖ Kennel '{} {}' installed successfully!",
        &package.name, &version
    );
}

pub fn remove_package(package: &str) {
    create_package_dir();

    let package_path = get_package_path().join(&package);

    if package_path.exists() {
        let _ = fs::remove_dir_all(&package_path);
    } else {
        println!("ü§î Kennel '{}' not installed", &package);
        println!(
            "üí° To install, try {BOLD}`glang install {}`{RESET}",
            &package
        );

        return;
    }

    let kennels_file = get_package_path().join("kennels.glang");
    let contents = fs::read_to_string(&kennels_file)
        .expect("Error reading 'kennels.glang'")
        .lines()
        .filter(|line| !line.contains(&package))
        .collect::<Vec<_>>()
        .join("\n");

    let _ = fs::write(&kennels_file, contents);

    println!("üóëÔ∏è  Kennel '{}' removed", &package);
}
