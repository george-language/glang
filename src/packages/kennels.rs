use reqwest::blocking::get;
use serde::Deserialize;
use simply_colored::*;
use std::{
    fs,
    io::Read,
    path::{Path, PathBuf},
};
use std::{fs::File, io::Cursor};
use toml::Table;
use zip::ZipArchive;

#[derive(Deserialize)]
struct PackageRegistry {
    name: String,
    url: String,
}

fn get_package_path() -> PathBuf {
    std::env::var("GLANG_PKG")
        .map(PathBuf::from)
        .unwrap_or_else(|_| PathBuf::from("kennels")) // fallback default
}

pub fn create_package_dir() {
    let kennels_dir = get_package_path();

    if !kennels_dir.exists() {
        match fs::create_dir_all(&kennels_dir) {
            Ok(_) => {}
            Err(e) => {
                println!("Error: {}", e);
                return;
            }
        }

        let _ = fs::write(
            kennels_dir.join("kennels.glang"),
            "# this file is automatically generated and edited by glang
# not intended for manual editing

obj std_os = _env(\"GLANG_STD\") + \"/std/os.glang\";
obj std_hashmap = _env(\"GLANG_STD\") + \"/std/hashmap.glang\";
obj std_format = _env(\"GLANG_STD\") + \"/std/format.glang\";
obj std_math = _env(\"GLANG_STD\") + \"/std/math.glang\";",
        );
    }
}

pub fn add_package(name: &str) {
    create_package_dir();

    let mut resp = match get(
        "https://raw.githubusercontent.com/mpsoftwarefoundation/GeorgeLanguage/main/registry.json",
    ) {
        Ok(r) => r,
        Err(e) => {
            println!("Failed to fetch registry: {}", e);

            return;
        }
    };

    let mut registry_json = String::new();

    if let Err(e) = resp.read_to_string(&mut registry_json) {
        println!("Failed to read registry data: {}", e);

        return;
    }

    let packages: Vec<PackageRegistry> = match serde_json::from_str(&registry_json) {
        Ok(p) => p,
        Err(e) => {
            println!("Failed to parse registry JSON: {}", e);

            return;
        }
    };

    let package = match packages.iter().find(|p| p.name == name) {
        Some(p) => p,
        None => {
            println!("{DIM_RED}Package '{}' not found in registry.{RESET}", name);

            return;
        }
    };

    let package_path = get_package_path().join(&package.name);

    if package_path.exists() {
        println!("‚úÖ Package '{}' is already installed", package.name);
        println!("üí° To update, use `glang update {}`", package.name);

        return;
    }

    println!("üìÅ Downloading package from: {}", package.url);

    let zip_bytes = match get(&package.url) {
        Ok(r) => match r.bytes() {
            Ok(b) => b,
            Err(e) => {
                println!("Failed to get zip content: {}", e);

                return;
            }
        },
        Err(e) => {
            println!("Failed to download zip: {}", e);

            return;
        }
    };

    println!(
        "üéØ Extracting package to: '{}'",
        package_path.to_string_lossy().to_string()
    );

    let reader = Cursor::new(zip_bytes);
    let mut archive = match ZipArchive::new(reader) {
        Ok(archive) => archive,
        Err(e) => {
            println!("Failed to open zip archive: {}", e);

            return;
        }
    };

    for i in 0..archive.len() {
        let mut file = archive.by_index(i).unwrap();
        let path = match file.enclosed_name() {
            Some(p) => {
                let mut components = p.components();
                components.next();

                let stripped = components.as_path();
                package_path.join(stripped)
            }
            None => continue,
        };

        if file.name().ends_with('/') {
            fs::create_dir_all(&path).unwrap_or_else(|e| {
                println!("Failed to create dir {:?}: {}", path, e);
            });
        } else {
            if let Some(parent) = path.parent() {
                fs::create_dir_all(parent).unwrap_or_else(|e| {
                    println!("Failed to create dir {:?}: {}", parent, e);
                });
            }

            let mut outfile = File::create(&path).unwrap();
            std::io::copy(&mut file, &mut outfile).unwrap();
        }
    }

    println!("üëç Updating 'kennels.glang'");

    let package_toml =
        fs::read_to_string(get_package_path().join(&package.name).join("kennel.toml"))
            .expect("Error reading 'kennel.toml'")
            .as_str()
            .parse::<Table>()
            .unwrap();
    let imports_file = get_package_path().join("kennels.glang");

    let mut imports = fs::read_to_string(&imports_file).expect("Error reading 'kennels.glang'");
    imports.push_str(
        format!(
            "obj {} = _env(\"GLANG_PKG\") + \"/{}/{}\"; # {} {}: {}\n",
            package_toml["name"],
            package_toml["name"],
            package_toml["entry"],
            package_toml["name"],
            package_toml["version"],
            package_toml["description"],
        )
        .as_str(),
    );
    let _ = fs::write(&imports_file, imports);

    println!(
        "‚úÖ Package '{}' '{}' installed successfully!",
        package_toml["name"], package_toml["version"]
    );
}

pub fn remove_package(package: &str) {
    create_package_dir();

    let package_path = get_package_path().join(&package);

    if package_path.exists() {
        let _ = fs::remove_dir_all(&package_path);
    } else {
        println!("Package '{}' not installed", &package);

        return;
    }

    let kennels_file = get_package_path().join("kennels.glang");
    let contents = fs::read_to_string(&kennels_file)
        .expect("Error reading 'kennels.glang'")
        .lines()
        .filter(|line| !line.contains(&package))
        .collect::<Vec<_>>()
        .join("\n");

    let _ = fs::write(&kennels_file, contents);

    println!("‚úÖ Package '{}' removed", &package);
}
